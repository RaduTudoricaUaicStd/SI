from utils import *
from hashlib import sha1
from sys import argv, stdout, stderr
from socket import socket

if len(argv) < 6:
	print("Mod de utilizare:", argv[0], "<ip:port pentru KM> <ip:port pentru B> <parola din care va fi derivata K3> <modul de comunicare> <fisierul care va fi trimis>")
	exit()

KM_addr = argv[1].split(":")
B_addr = argv[2].split(":")
K3 = sha1(argv[3].encode('utf-8')).digest()[:16]
IV = b"0123456789ABCDEF"

try:
	print("[*] Connecting to KM")
	KM = socket()
	KM.connect((KM_addr[0], int(KM_addr[1])))
except:
	print("[!] Counld not connect to the KM")
	exit()

try:
	print("[*] Connecting to B")
	B = socket()
	B.connect((B_addr[0], int(B_addr[1])))
except:
	print("[!] Counld not connect to the B")
	exit()

print("[*] Sending to B and KM the op mode")
B.send(argv[4].encode("utf-8"))
KM.send(argv[4].encode("utf-8"))

encrypted_key = KM.recv(16)
print("[*] Received the encrypted key, sending it to node B")
B.send(encrypted_key)
key = aes_decrypt_block(encrypted_key, K3)

try:
	assert aes_decrypt_block(B.recv(16), K3) == sha1(key).digest()[:16]
	print("[*] Node B passed the K3 knowing proof, sending the file now")
except:
	print("[!] Node B doesn't know K3, exiting")
	exit()

file = open(argv[5], 'rb')
if argv[4] == "ECB":
	encryptor = aes_ecb_encrypt(iter( lambda: file.read(16), b'' ), key)
elif argv[4] == "CFB":
	encryptor = aes_cfb_encrypt(iter( lambda: file.read(16), b'' ), key, IV)
else:
	encryptor = aes_ecb_encrypt(iter( lambda: file.read(16), b'' ), key, IV)

for block in encryptor:
	B.send(block)
B.close()
file.close()from utils import *
from hashlib import sha1
from sys import argv, stdout, stderr
from socket import socket

if len(argv) < 3:
	print("Mod de utilizare:", argv[0], "<ip:port pentru bind si listen> <parola din care va fi derivata K3>")
	exit()

ip, port = argv[1].split(":")
K3 = sha1(argv[2].encode('utf-8')).digest()[:16]
IV = b"0123456789ABCDEF"

def receive_file_handler(client, ip_port):
	ip_port = ip_port[0] + ":" + str(ip_port[1])
	print("[server -- info] New client", ip_port, file = stderr)
	key_type = client.recv(3)
	key = aes_decrypt_block(client.recv(16), K3)
	print("["+ip_port+" -- info] Decrypted key", file = stderr)
	proof = aes_encrypt_block(sha1(key).digest()[:16], K3)
	decryptor = None
	if key_type == b"ECB":
		print("["+ip_port+" -- info] Client uses ECB", file = stderr)
		decryptor = aes_ecb_decrypt(iter( lambda: client.recv(16), b'' ), key)
	elif key_type == b"CFB":
		print("["+ip_port+" -- info] Client uses CFB", file = stderr)
		decryptor = aes_cfb_decrypt(iter( lambda: client.recv(16), b'' ), key, IV)
	else:
		print("["+ip_port+" -- info] Unknown mode, defaulting to CFB", file = stderr)
		decryptor = aes_cfb_decrypt(iter( lambda: client.recv(16), b'' ), key, IV)

	print("["+ip_port+" -- info] Finishing the handshake by sending the proof that i know the key", file = stderr)
	client.send(proof)
	print("["+ip_port+" -- info] Reading the file to stdout", file = stderr)
	for block in decryptor:
		stdout.buffer.write(block)

	stdout.flush()
	client.close()

try:
	create_server(ip, port, receive_file_handler)
except Exception as e:
	print("[!!!] Server is closing", file = stderr)